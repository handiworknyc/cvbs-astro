---
import { normalizeLayouts, type NormRow } from "./normalize";
import { getEnv, toBase64 } from "../env.ts"; // path is one dir up

// Props coming *into* this renderer
interface Props {
  layouts?: any[];
  /** Optional: "service" | "service-area" to mirror hw_get_current_taxonomy_context() */
  taxContext?: string | null;
}

const {
  layouts = [],
  taxContext = null,
} = Astro.props as Props;

// Env (server-side is fine for non-PUBLIC_ here)
const WP_BASE = import.meta.env.WP_BASE_URL || "";
const WP_AUTH_BASIC = getEnv("WP_AUTH_BASIC") || ""; // "user:pass"
const slug = Astro.params?.slug as string | undefined;

// Build auth headers once
const authHeaders = WP_AUTH_BASIC
  ? { Authorization: `Basic ${toBase64(WP_AUTH_BASIC)}` }
  : {};

// -----------------------------
// Debug + fetch state (page)
// -----------------------------
let currentPost: any = null;
let fetchStatus: number | null = null;
let fetchUrl = "";
let fetchPeek = "";
let fetchError: string | null = null;

// -----------------------------
// Debug + fetch state (term)
// -----------------------------
let currentTerm: any = null;
let termFetchStatus: number | null = null;
let termFetchUrl = "";
let termFetchPeek = "";
let termFetchError: string | null = null;

if (!WP_BASE) {
  console.error("[layoutrenderer] Missing WP_BASE_URL");
}
if (!slug) {
  console.warn("[layoutrenderer] No slug param present");
}

async function fetchJson(url: string) {
  const res = await fetch(url, { headers: { Accept: "application/json", ...authHeaders } });
  const status = res.status;
  if (!res.ok) {
    const text = (await res.text().catch(() => ""))?.slice(0, 300) || "";
    return { ok: false, status, peek: text, json: null as any };
  }
  const json = await res.json();
  return { ok: true, status, peek: "", json };
}

// If we have a taxonomy context, resolve the *term* by slug.
// Otherwise, resolve the *page* by slug (original behavior).
if (WP_BASE && slug) {
  if (taxContext) {
    // --- Taxonomy mode: fetch term directly using provided taxContext ---
    try {
      termFetchUrl = `${WP_BASE}/wp-json/wp/v2/${encodeURIComponent(taxContext)}?slug=${encodeURIComponent(slug)}`;
      const r = await fetchJson(termFetchUrl);
      termFetchStatus = r.status;
      if (!r.ok) {
        termFetchPeek = r.peek;
        console.error("[layoutrenderer] TERM HTTP", termFetchStatus, termFetchUrl, termFetchPeek);
      } else {
        const terms = Array.isArray(r.json) ? r.json : [];
        currentTerm = terms?.[0] ?? null;
        console.log("[layoutrenderer] fetched TERM", {
          taxContext,
          slug,
          url: termFetchUrl,
          status: termFetchStatus,
          foundId: currentTerm?.id ?? null,
        });
      }
    } catch (e: any) {
      termFetchError = e?.message || String(e);
      console.error("[layoutrenderer] TERM fetch error", termFetchError, { url: termFetchUrl });
    }
  } else {
    // --- No taxContext: try page first ---
    try {
      fetchUrl = `${WP_BASE}/wp-json/wp/v2/pages?slug=${encodeURIComponent(slug)}`;
      const r = await fetchJson(fetchUrl);
      fetchStatus = r.status;
      if (r.ok) {
        const posts = Array.isArray(r.json) ? r.json : [];
        currentPost = posts?.[0] ?? null;
        console.log("[layoutrenderer] fetched PAGE", {
          slug,
          url: fetchUrl,
          status: fetchStatus,
          foundId: currentPost?.id ?? null,
        });
      } else {
        fetchPeek = r.peek;
        console.error("[layoutrenderer] PAGE HTTP", fetchStatus, fetchUrl, fetchPeek);
      }
    } catch (e: any) {
      fetchError = e?.message || String(e);
      console.error("[layoutrenderer] PAGE fetch error", fetchError, { url: fetchUrl });
    }

    // --- If not a page (or page has no match), probe known taxonomies for a term with this slug ---
    if (!currentPost) {
      for (const candTax of TAX_CANDIDATES) {
        try {
          const url = `${WP_BASE}/wp-json/wp/v2/${encodeURIComponent(candTax)}?slug=${encodeURIComponent(slug)}`;
          const r = await fetchJson(url);
          // keep debug of each probe
          console.log("[layoutrenderer] probe TERM", { candTax, status: r.status, url });

          if (r.ok) {
            const arr = Array.isArray(r.json) ? r.json : [];
            if (arr[0]?.id) {
              currentTerm = arr[0];
              termFetchUrl = url;
              termFetchStatus = r.status;
              // set taxContext dynamically so children receive taxonomy
              // (WP returns taxonomy in the term object for core and custom taxonomies)
              // if not present, fall back to candidate
              // @ts-ignore
              taxContext = typeof currentTerm?.taxonomy === "string" ? currentTerm.taxonomy : candTax;

              console.log("[layoutrenderer] detected TERM", {
                slug,
                taxonomy: taxContext,
                foundId: currentTerm.id,
              });
              break; // stop at first match
            }
          }
        } catch (e: any) {
          console.error("[layoutrenderer] probe TERM error", e?.message || String(e));
        }
      }
    }
  }
}


const postId = currentPost?.id ?? null;
const termId = currentTerm?.id ?? null;

// Prefer WP layouts when present (page ACF) â€” taxonomy pages may not have these.
const fetchedLayouts = currentPost?.acf?.layouts ?? null;
const effectiveLayouts = Array.isArray(fetchedLayouts) && fetchedLayouts.length > 0
  ? fetchedLayouts
  : layouts;

// Normalize to { name, key, data, meta }
const rows: NormRow[] = normalizeLayouts(effectiveLayouts);

/**
 * Auto-register all components in ./components/flex
 */
const modules = import.meta.glob("/src/components/flex/*.astro", { eager: true });

// Build registry: { "hero_text": <Component>, ... }
const REGISTRY: Record<string, any> = {};
for (const [p, mod] of Object.entries(modules)) {
  const file = p.split("/").pop() || "";
  const key = file.replace(/\.astro$/i, "");
  // @ts-expect-error default is the astro component
  REGISTRY[key] = (mod as any).default;
}

// Helpers to resolve a component from a layout name
function toKebab(s: string) {
  return s.replace(/[_\s]+/g, "-").replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function toSnake(s: string) {
  return s.replace(/[-\s]+/g, "_").replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
}
function toCamel(s: string) {
  const base = s.replace(/[-_ ]+(\w)/g, (_, c) => (c ? c.toUpperCase() : ""));
  return base.charAt(0).toLowerCase() + base.slice(1);
}
function resolveComponent(layoutName: string) {
  if (REGISTRY[layoutName]) return REGISTRY[layoutName];
  const cands = [toKebab(layoutName), toSnake(layoutName), toCamel(layoutName)];
  for (const k of cands) if (REGISTRY[k]) return REGISTRY[k];
  return null;
}

// Background logic
const firstLayout = rows[0]?.name ?? "";

function isAltBgContext(): boolean {
  const taxOk = taxContext === "service" || taxContext === "service-area";
  return taxOk || firstLayout === "service_area_banner";
}

function computeBgWrapClass(row: NormRow, rowindex: number): string | null {
  const ls = (row as any)?.data?.layout_settings ?? {};
  const bgColor: string = typeof ls?.bg_color === "string" ? ls.bg_color.trim() : "";
  const toBgClass = (val: string) => {
    const v = val.toLowerCase();
    if (!v || v === "none") return null;
    if (/\bbg-1\b/.test(v)) return v;
    return `${v}bg-1`;
  };
  const explicit = toBgClass(bgColor);
  if (explicit) return explicit;
  if (isAltBgContext() && rowindex >= 2) {
    return rowindex % 2 === 0 ? "whitebg-1" : "mintbg-1";
  }
  return null;
}
---

{rows.length === 0 && (
  <div class="prose mx-auto my-12 text-center opacity-70">
    <p>No content yet.</p>
  </div>
)}
<!-- 
{/* Visible debug panel:
    - If page mode and page fetch failed
    - If taxonomy mode and term fetch failed
*/}
{(slug && (
  (!taxContext && (!postId || (fetchStatus && fetchStatus >= 400) || fetchError)) ||
  (taxContext && (!termId || (termFetchStatus && termFetchStatus >= 400) || termFetchError))
)) && (
  <div style="margin:1rem auto; max-width:64rem; padding:1rem; border:1px dashed #c33; background:#fff3f3; font-family:monospace; font-size:.9rem;">
    <div><strong>WP_BASE_URL:</strong> {WP_BASE || "(not set)"} </div>
    <div><strong>slug:</strong> {slug}</div>
    <div><strong>mode:</strong> {taxContext ? `taxonomy:${taxContext}` : "page"} </div>

    {!taxContext ? (
      <>
        <div><strong>request (page):</strong> {fetchUrl}</div>
        <div><strong>status:</strong> {String(fetchStatus ?? "")}</div>
        <div><strong>error:</strong> {String(fetchError ?? "")}</div>
        <div><strong>peek:</strong> {fetchPeek}</div>
        <div><strong>postId:</strong> {String(postId)}</div>
      </>
    ) : (
      <>
        <div><strong>request (term):</strong> {termFetchUrl}</div>
        <div><strong>status:</strong> {String(termFetchStatus ?? "")}</div>
        <div><strong>error:</strong> {String(termFetchError ?? "")}</div>
        <div><strong>peek:</strong> {termFetchPeek}</div>
        <div><strong>termId:</strong> {String(termId)}</div>
        <div><strong>taxonomy:</strong> {taxContext}</div>
      </>
    )}

    <div><strong>auth:</strong> {WP_AUTH_BASIC ? "(Basic auth supplied)" : "(no auth)"} </div>
  </div>
)} -->

{rows.map((row, idx) => {
  const Comp = resolveComponent(row.name);
  const rowindex = idx + 1; // 1-based index

  const idAttr = row.meta.id ? { id: row.meta.id } : {};
  const sectionClass = ["flex-bg", ...row.meta.classes].join(" ").trim();

  const bgWrapClass = computeBgWrapClass(row, rowindex);
  const innerWrapClasses = [
    "flex-bg-inner",
    "z-[100]",
    "pr",
    ...(row.meta?.ofh ? ["ofh"] : []),
  ].join(" ");

  // Pass *both* page and taxonomy context into every sub-layout.
  // Components that support pull-through can decide which to use:
  //  - For pages:    use postId/currentPost
  //  - For taxonomy: use termId + taxonomy (taxContext)
const termId = currentTerm?.id ?? null;
const postId = currentPost?.id ?? null;

const commonCtx = {
  postId,
  currentPost,
  termId,
  taxonomy: (taxContext || (typeof currentTerm?.taxonomy === "string" ? currentTerm.taxonomy : null)) as string | null,
  currentTerm,
  rowIndex: rowindex,
};

console.log("[layoutrenderer] term context", {
  taxContext,
  slug,
  resolvedTermId: termId,
  termFetchUrl,
  termFetchStatus,
  currentTermTaxonomy: currentTerm?.taxonomy,
});

  return (
    <section {...idAttr} class={sectionClass}>
      {row.meta.preHtml && <div set:html={row.meta.preHtml} />}

      {bgWrapClass ? (
        <div class={bgWrapClass}>
          <div class={innerWrapClasses}>
            {Comp ? (
              <Comp {...row.data} {...commonCtx} />
            ) : (
              <div class="mx-auto my-8 max-w-5xl rounded-xl border p-4">
                <p class="font-semibold">
                  Unknown layout: <code>{row.name}</code>
                </p>
                <p class="text-sm mt-1">
                  Create <code>src/lib/wp/components/flex/{toSnake(row.name)}.astro</code> (or{" "}
                  <code>{toKebab(row.name)}.astro</code>) to handle this layout.
                </p>
                <details class="mt-2">
                  <summary class="cursor-pointer">Inspect data</summary>
                  <pre class="mt-2 overflow-auto text-sm">
                    {JSON.stringify(row.data, null, 2)}
                  </pre>
                </details>
              </div>
            )}
          </div>
        </div>
      ) : (
        <>
          {Comp ? (
            <Comp {...row.data} {...commonCtx} />
          ) : (
            <div class="mx-auto my-8 max-w-5xl rounded-xl border p-4">
              <p class="font-semibold">
                Unknown layout: <code>{row.name}</code>
              </p>
              <p class="text-sm mt-1">
                Create <code>src/lib/wp/components/flex/{toSnake(row.name)}.astro</code> (or{" "}
                <code>{toKebab(row.name)}.astro</code>) to handle this layout.
              </p>
              <details class="mt-2">
                <summary class="cursor-pointer">Inspect data</summary>
                <pre class="mt-2 overflow-auto text-sm">
                  {JSON.stringify(row.data, null, 2)}
                </pre>
              </details>
            </div>
          )}
        </>
      )}
    </section>
  );
})}
